---
title: "Isolates Metabarcoding"
author: "Rodrigo Taketani"
date: "`r Sys.Date()`"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, dpi = 300)
```

# Importing data

The DNA obtained from the isolates were set to Novogene for 16S metabarcoding of the isolates polled per pot, i.e. each sample represent one of the replicates of the UK Crop Microbiome Cryobank glasshouse experiment. The samples presented here are the same used for functional characterization of the isolates. 

The sequences obtained from Novogene were analysed in Qiime2 using DADA2, vsearch and Silva138 database as described below. We used the demultiplexed, chimer checked and merged-pair sequences provided by Novogene.

```{bash qiime2 script, eval = FALSE}

# Import sequences to qiime2 artifact.

qiime tools import \
  --type 'SampleData[SequencesWithQuality]' \
  --input-path manifers.tsv \
  --output-path single-end-demux.qza \
  --input-format SingleEndFastqManifestPhred33V

#Denoise with Dada2

qiime dada2 denoise-single \
 	--i-demultiplexed-seqs single-end-demux.qza \
 	--p-trim-left 0 \
 	--p-trunc-len 0 \
 	--p-trunc-q 1 \
 	--p-max-ee 5 \
 	--o-representative-sequences rep-seqs.qza \
 	--o-table table.qza \
 	--o-denoising-stats stats.qza \
 	--verbose \
 	--p-n-threads 31
 	
# Remove singletons and doubletons

qiime feature-table filter-features \
  --i-table table.qza \
  --p-min-frequency 2 \
  --o-filtered-table filtered-table.qza

# Filter sequences (*min-frequency) ~Remove sequences based on the filtered feature table"

qiime feature-table filter-seqs \
  --i-data rep-seqs.qza \
  --i-table filtered-table.qza \
  --o-filtered-data filtered-seqs.qza \
  --verbose	
  

# "Generate a tree for phylogenetic diversity analyses"
qiime phylogeny align-to-tree-mafft-fasttree \
  --i-sequences filtered-seqs.qza \
  --o-alignment aligned-rep-seqs.qza \
  --o-masked-alignment masked-aligned-rep-seqs.qza \
  --o-tree unrooted-tree.qza \
  --o-rooted-tree rooted-tree.qza 
  

# "Taxonomy analyses (with Vsearch consensus taxonomy classifier)"
qiime feature-classifier classify-consensus-vsearch \
--i-query filtered-seqs.qza \
--i-reference-reads /home/data/mmeg_ngs/rodrigo_taketani/mng2/silva-138-99-seqs.qza \
--i-reference-taxonomy /home/data/mmeg_ngs/rodrigo_taketani/mng2/silva-138-99-tax.qza  \
--o-classification taxonomy_modified.qza \
--o-search-results tax_search_results.qza \
--p-threads 31 \
--verbose

# "Export files for phyloseq (Taxonomy Table)"
qiime tools export \
--input-path taxonomy_modified.qza \
--output-path phyloseq_modified
#
# "Export files for phyloseq (Phylogenetic Tree)"
qiime tools export \
--input-path rooted-tree.qza \
--output-path phyloseq_modified
#
# "Export files for phyloseq (Feature Table) "
qiime tools export \
--input-path filtered-table.qza \
--output-path phyloseq_modified

# Add taxonomy to biom file
cd phyloseq_modified

var="#OTUID\ttaxonomy\tconfidence"

sed -i "1s/.*/$var/" taxonomy.tsv

biom add-metadata -i feature-table.biom -o table_tax.biom --observation-metadata-fp taxonomy.tsv

```


## Import data to R

```{r Import}

library(phyloseq)
#Import Mapping File

sample_data_iso <- readxl::read_excel("./phyloseq_modified/sample.xlsx") # description of the pot experiment metadata

AgMicrobiome_RR <- readxl::read_excel("../R_functional_tool/AgMicrobiome-RR.xlsx", sheet = "Soils") # Data from the source soils

sample_metadata_iso <- merge(sample_data_iso, AgMicrobiome_RR, by = "Sample name", all.x = TRUE) 


library(dplyr)

#sample_metadata_iso <- sample_metadata_iso %>%
#  select(`sample-id`, everything())
row.names(sample_metadata_iso) <- sample_metadata_iso$`sample-id`

sample_metadata_iso$pot <- gsub("-", ".", sample_metadata_iso$pot)
sample_metadata_iso$`Soil Id` <- gsub("-", ".", sample_metadata_iso$`Soil Id`)

#Import OTU table 
#data in json.biom

otutableBac=import_biom(BIOMfilename="./phyloseq_modified/table_tax.biom",
                        parseFunction=parse_taxonomy_default)

tree <- ape::read.tree("phyloseq_modified/tree.nwk")

#tree = system.file("extdata", "phyloseq_modified/tree.nwk", package="phyloseq")

#Creating phyloseq object

bac_phylo = merge_phyloseq(otutableBac, sample_data(sample_metadata_iso), tree)

taxa_names(bac_phylo) <- paste("OTU.", formatC(seq(ntaxa(bac_phylo)), 
                                               width = nchar(ntaxa(bac_phylo)),
                                               flag = "0"), 
                               sep="")

# Adjust rank names
colnames(tax_table(bac_phylo)) = c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species")
rank_names(bac_phylo) 

sample_names(bac_phylo) <- sample_data(bac_phylo)$pot

sample_names(bac_phylo)

# Remove organelles

bac_phylo <- bac_phylo %>% subset_taxa( Family!= "c__mitochondria" & Class!="c__Chloroplast" ) 
bac_phylo <- bac_phylo %>% subset_taxa( Kingdom!= "Unassigned" | is.na(Phylum)) 

# Extract the taxonomy table
tax_table_original <- tax_table(bac_phylo)

# Remove the prefix (e.g., p__, c__, etc.) using gsub
# The regex pattern "^.+"__ matches any letter followed by `__`
tax_table_cleaned <- apply(tax_table_original, 2, function(x) gsub("^.+__", "", x))

# Replace the taxonomy table in the phyloseq object
tax_table(bac_phylo) <- tax_table(tax_table_cleaned)

# Check the updated taxonomy table
head(tax_table(bac_phylo))


```


## Aesthetic defaults

We will set a labels, colors, and shapes to represent the different treatments on the plots. This consistency will help with the readability of the plots. 

```{r Aesthetic variables}
# Aestetic parameters

colorvec <- c("AN" = "#005F73",
              "BE"  = "#0A9396",
              "BO" = "#94D2BD",
              "BU" = "#E9D8A6",
              "HE" = "#EE9B00",
              "SH" = "#CA6702",
              "YO" = "#BB3E03",
              "CL" = "#251605",
              "CY" = "#c57b57",
              "SC" = "#f1ab86",
              "SL" = "#f7dba7",
              "Barley" = "#0e181b", 
              "Oats" = "#1f363d", 
              "Wheat" = "#40798c", 
              "Beans" = "#70a9a1", 
              "OilseedRape" = "#9ec1a3", 
              "OSR" = "#9ec1a3", 
              "Sugarbeet" = "#cfe0c3", 
              "Bulksoil" = "#E9D8A6",
              "Bulk" = "#E9D8A6",
              "CL" = "#251605",
              "CY" = "#c57b57",
              "SC" = "#f1ab86",
              "SL" = "#f7dba7",
              "Clay loam" = "#251605",
              "Clay" = "#c57b57",
              "Silty clay loam" = "#f1ab86",
              "Sandy loam" = "#f7dba7",
              "CL.BO" = "#2c2c54",
              "SL.AN" = "#474787",
              "CL.YO" = "#227093",
              "CY.YO" = "#218c74",
              "SC.HE" = "#b33939",
              "CY.BU" = "#cd6133",
              "SL.BE" = "#cc8e35",
              "SC.SH" = "#ccae62",
              "SL.SH" = "#84817a"
              )

shapesvec <- c("Barley" = 3, "Beans" = 15, 
               "Bulksoil" = 16, "Oats" = 17, 
               "OilseedRape" = 18, "Sugarbeet" = 25, 
               "Wheat" = 0,
               "AN" = 3, "BE" = 15, 
               "BO" = 16, "BU" = 17, 
               "HE" = 18, "SH" = 25, 
               "YO" = 0)

labelsvec <- c("AN" = "Angus",
              "BE"  = "Bedfordshire",
              "BO" = "Borders",
              "BU" = "Buckinghamshire",
              "HE" = "Hertfordshire",
              "SH" = "Shropshire",
              "YO" = "Yorkshire",
              "Barley" = "Barley",
              "Beans" = "Beans", 
              "Bulksoil" = "Bulk soil",
              "Bulk" = "Bulk soil",
              "Oats" = "Oats", 
              "OilseedRape" = "Oilseed Rape", 
              "OSR" = "Oilseed Rape",
              "Sugarbeet" = "Sugarbeet", 
              "Wheat" = "Wheat",
              "CL" = "Clay loam",
              "CY" = "Clay",
              "SC" = "Silt clay loam",
              "SL" = "Sandy loam",
              "Clay loam" = "Clay loam",
              "Clay" = "Clay",
              "Silty clay loam" = "Silt clay loam",
              "Sandy loam" = "Sandy loam",
              "CL.BO" = "Borders",
              "CL.YO" = "Yorkshire-CL",
              "CY.BU" = "Buckinghamshire",
              "CY.YO" = "Yorkshire-CY",
              "SC.HE" = "Hertfordshire",
              "SC.SH" = "Shropshire-SC",
              "SL.AN" = "Angus",
              "SL.BE" = "Bedfordshire",
              "SL.SH" = "Shropshire-SL"
              )

crop_order = c("Barley", "Oats", "Wheat", "Beans", "OSR", "Sugarbeet", "Bulk")

local_order = c("CL.BO", "SL.AN", "CL.YO", "CY.YO", "SC.HE", "CY.BU", "SL.BE", "SC.SH", "SL.SH")

tax_color = c("Acidimicrobiia"  = "#001219",
              "Acidobacteriae"  ="#003441",
              "Actinobacteria" = "#00576A",
              "Alphaproteobacteria"  = "#03717F",
              "Bacilli" = "#08888F",
              "Bacteroidia"  = "#2CA29F",
              "Blastocatellia"  = "#6ABFB1",
              "Chloroflexia"   = "#A0D2B9",
              "Clostridia" = "#C7D5AF",
              "Gammaproteobacteria"  = "#E9D49D",
              "Gemmatimonadetes"  =   "#EBB953",   
              "KD4-96"   =  "#ED9E08",
              "MB-A2-108"  =   "#DF8600",
              "Nitrospiria" = "#CF6E01",
              "Phycisphaerae" = "#C55A02", 
              "Planctomycetes"  =   "#BE4802",
              "Polyangia" =   "#B83706",
              "Thermoleophilia" =   "#B22A0C", 
              "Verrucomicrobiae"  = "#AC2014",
              "Vicinamibacteria" =  "#A3211D")

```


# Eliminate contaminants and normalize data

Considering we have 20% of cultures that did not grow again and 20% of cultures that are mixed. So, we expect that the maximum number of ASVs per plate should be close to 100. With the data above, we considered that 0.05% is the reasonable cut-off. 

```{r Normalise}
phylo_relative <- transform_sample_counts(bac_phylo, function(x) (x / sum(x)) * 100)
  
# Set values below cut-off to zero
otu_table(phylo_relative)[otu_table(phylo_relative) < 0.05] <- 0
  
# Prune taxa that are zero in all samples
bac_phylo_norm <- prune_taxa(taxa_sums(phylo_relative) > 0, phylo_relative)

# Do normalization again
bac_phylo_norm <- transform_sample_counts(bac_phylo_norm, function(x) (x / sum(x)) * 100)




```


# Alpha-diversity measurements

Here we will evaluate the differences in alpha diversity indexes of the samples. We will calculate Sobs, Pielou's Evenness, and Shannon's H'.

```{r}
# Calculate the Sobs, Pielou's Evenness, and Shannon's H'
library(picante)
library(vegan)

physeq.norm.raref <- bac_phylo_norm
community_matrix <- as(t(otu_table(physeq.norm.raref)), "matrix")

# Calculate Observed Species (Sobs)
Sobs <- specnumber(community_matrix)

# Calculate Shannon Diversity Index
shannon_index <- vegan::diversity(community_matrix, index = "shannon")

# Calculate Pielou's Evenness
pielou_evenness <- shannon_index / log(Sobs)


# Create a data frame with the results
diversity_table <- data.frame(
  Sample = rownames(community_matrix),
  Sobs = Sobs,
  Shannon = shannon_index,
  Pielou = pielou_evenness
)

# Print the diversity table
print(diversity_table)

```


First we prepare the data.

```{r}
library(tibble)
library(dplyr)
# Extract the sample data
sample_data_df <- data.frame(sample_data(physeq.norm.raref))
sample_data_df <- sample_data_df %>% rownames_to_column("Sample")

# Merge the diversity index with the sample data based on sample names

merged_sample_data_iso <- merge(sample_data_df, diversity_table, by = "Sample")

```

Below we will plot and compare the diversity indexes by location, crop and soil type. first will test the normality of the data using Shapiro-Wilk

```{r}
#Shannon
shapiro_test_shannon_crop <- by(merged_sample_data_iso$Shannon, merged_sample_data_iso$Crop, shapiro.test) #shapiro.test(diversity_table$Shannon)
print(shapiro_test_shannon_crop)

shapiro_test_shannon_location <- by(merged_sample_data_iso$Shannon, merged_sample_data_iso$Soil.Id, shapiro.test) #shapiro.test(diversity_table$Shannon)
print(shapiro_test_shannon_location)

shapiro_test_shannon_soil <- by(merged_sample_data_iso$Shannon, merged_sample_data_iso$Textural.class, shapiro.test) #shapiro.test(diversity_table$Shannon)
print(shapiro_test_shannon_soil)

#Sobs
shapiro_test_sobs_crop <- by(merged_sample_data_iso$Sobs, merged_sample_data_iso$Crop, shapiro.test) #shapiro.test(diversity_table$Sobs)
print(shapiro_test_sobs_crop)
shapiro_test_sobs_location <- by(merged_sample_data_iso$Sobs, merged_sample_data_iso$Soil.Id, shapiro.test) #shapiro.test(diversity_table$Sobs)
print(shapiro_test_sobs_location)
shapiro_test_sobs_soil <- by(merged_sample_data_iso$Sobs, merged_sample_data_iso$Textural.class, shapiro.test) #shapiro.test(diversity_table$Sobs)
print(shapiro_test_sobs_soil)

#Pielou
shapiro_test_Pielou_crop <- by(merged_sample_data_iso$Pielou, merged_sample_data_iso$Crop, shapiro.test) #shapiro.test(diversity_table$Pielou)
print(shapiro_test_Pielou_crop)

shapiro_test_Pielou_location <- by(merged_sample_data_iso$Pielou, merged_sample_data_iso$Soil.Id, shapiro.test) #shapiro.test(diversity_table$Pielou)
print(shapiro_test_Pielou_location)

shapiro_test_Pielou_soil <- by(merged_sample_data_iso$Pielou, merged_sample_data_iso$Textural.class, shapiro.test) #shapiro.test(diversity_table$Pielou)
print(shapiro_test_Pielou_soil)

```

Normality was rejected, so, we will test differences using Kruskal-Wallis.


## Shannon H'
Then let's start looking at the Shannon results.

```{r}

# Here I deficne a fuction to get letters from pairwise test 
# Define the function
generate_significant_letters <- function(p_values_matrix) {
  
  # Load necessary library for generating letters
  library(multcompView)
  
  # Get the location names
  
  location_names <- rownames(p_values_matrix)
  
  # Add a first row with NAs and the name of the first column
  first_row <- c(NA, rep(NA, ncol(p_values_matrix)))
  #rownames(p_values_matrix)[1] <- colnames(p_values_matrix)[1]
  p_values_matrix <- rbind(first_row, p_values_matrix)
  rownames(p_values_matrix)[1] <- colnames(p_values_matrix)[1]
  # Add a last column with NAs and the name of the last row
  p_values_matrix <- cbind(p_values_matrix, NA)
  colnames(p_values_matrix)[ncol(p_values_matrix)] <- rownames(p_values_matrix)[nrow(p_values_matrix)]
  
  # Fill the diagonal with 1s to avoid issues with self-comparisons
  #diag(p_values_matrix) <- 1
  
  # Generate letters for the significant differences
  significant_letters <- multcompLetters(p_values_matrix)$Letters
  
  # Return the significant letters
  return(significant_letters)
}
```

### Location:

```{r}

#Location

# Perform the Kruskal-Wallis test
kruskal_test <- kruskal.test(Shannon ~ Soil.Id, data = merged_sample_data_iso)

# Print the result of the Kruskal-Wallis test
print(kruskal_test)

# Extract the p-value
p_value <- kruskal_test$p.value

# Format the p-value for display
p_value_text <- paste0("p = ", formatC(p_value, format = "e", digits = 2))

# Perform pairwise comparisons using Wilcox on rank-sum test
pairwise_comparisons <- pairwise.wilcox.test(merged_sample_data_iso$Shannon, merged_sample_data_iso$Soil.Id, p.adjust.method = "BH")

# Print the pairwise comparison results
print(pairwise_comparisons)

p_values_matrix <- pairwise_comparisons$p.value

# Generate letters for significant differences using the custom function
significant_letters <- generate_significant_letters(p_values_matrix)


# Create a data frame for the letters to use in plotting
letters_df <- data.frame(Soil.Id = names(significant_letters), Letters = significant_letters)

# Create a boxplot with letters
library(ggplot2)
sha_loc_plot <- ggplot(merged_sample_data_iso, aes(x = Soil.Id, y = Shannon, fill = Soil.Id)) +
                        geom_boxplot() +
                        labs(x = "Location", y = "Shannon's H'") +
                        geom_jitter(show.legend = FALSE, width = 0.2, alpha = 0.3) + 
                        theme_classic() +
                        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                        geom_text(data = letters_df, aes(x = Soil.Id, y = max(merged_sample_data_iso$Shannon)  * 1.1, 
                                                         label = Letters), 
                                  vjust = -0.5, color = "darkgray", size = 4) +
                        scale_fill_manual(values = colorvec, name = NULL) +
                        scale_x_discrete(labels = labelsvec, limits = local_order) +
                        theme(legend.position = "none")+
                        annotate("text", x = 5, y = max(merged_sample_data_iso$Shannon) + 1.27, label = p_value_text, size = 4) +
                        coord_cartesian(ylim = c(0, max(merged_sample_data_iso$Shannon) + 1.35))


sha_loc_plot

```

### Crop:

```{r}
#Crop

# Perform the Kruskal-Wallis test
kruskal_test <- kruskal.test(Shannon ~ Crop, data = merged_sample_data_iso)

# Print the result of the Kruskal-Wallis test
print(kruskal_test)

# Extract the p-value
p_value <- kruskal_test$p.value

# Format the p-value for display
p_value_text <- paste0("p = ", formatC(p_value, format = "e", digits = 2))

# Perform pairwise comparisons using Wilcox on rank-sum test
pairwise_comparisons <- pairwise.wilcox.test(merged_sample_data_iso$Shannon, merged_sample_data_iso$Crop, p.adjust.method = "BH")

# Print the pairwise comparison results
print(pairwise_comparisons)

p_values_matrix <- pairwise_comparisons$p.value

# Generate letters for significant differences using the custom function
significant_letters <- generate_significant_letters(p_values_matrix)


# Create a data frame for the letters to use in plotting
letters_df <- data.frame(Crop = names(significant_letters), Letters = significant_letters)

# Create a boxplot with letters
sha_crop_plot <- ggplot(merged_sample_data_iso, aes(x = Crop, y = Shannon, fill = Crop)) +
                        geom_boxplot() +
                        labs(x = "Crop", y = "Shannon's H'") +
                        geom_jitter(show.legend = FALSE, width = 0.2, alpha = 0.3) + 
                        theme_classic() +
                        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                        geom_text(data = letters_df, aes(x = Crop, y = max(merged_sample_data_iso$Shannon)  * 1.1, 
                                                         label = Letters), 
                                  vjust = -0.5, color = "darkgray", size = 4) +
                        scale_fill_manual(values = colorvec, name = NULL) +
                        scale_x_discrete(labels = labelsvec, limits = crop_order) +
                        theme(legend.position = "none")+
                        annotate("text", x = 4, y = max(merged_sample_data_iso$Shannon) + 1.27, label = p_value_text, size = 4) +
                        coord_cartesian(ylim = c(0, max(merged_sample_data_iso$Shannon) + 1.35))
  
  


sha_crop_plot
```


### Soil type:

```{r}
#Soil type

# Perform the Kruskal-Wallis test
kruskal_test <- kruskal.test(Shannon ~ Textural.class, data = merged_sample_data_iso)

# Print the result of the Kruskal-Wallis test
print(kruskal_test)

# Extract the p-value
p_value <- kruskal_test$p.value

# Format the p-value for display
p_value_text <- paste0("p = ", formatC(p_value, format = "e", digits = 2))

# Perform pairwise comparisons using Wilcox on rank-sum test
pairwise_comparisons <- pairwise.wilcox.test(merged_sample_data_iso$Shannon, merged_sample_data_iso$Textural.class, p.adjust.method = "BH")

# Print the pairwise comparison results
print(pairwise_comparisons)

p_values_matrix <- pairwise_comparisons$p.value

# Generate letters for significant differences using the custom function
significant_letters <- generate_significant_letters(p_values_matrix)


# Create a data frame for the letters to use in plotting
letters_df <- data.frame(Textural.class = names(significant_letters), Letters = significant_letters)

# Create a boxplot with letters
sha_Textural.class_plot <- ggplot(merged_sample_data_iso, aes(x = Textural.class, y = Shannon, fill = Textural.class)) +
                        geom_boxplot() +
                        labs(x = "Soil type", y = "Shannon's H'") +
                        geom_jitter(show.legend = FALSE, width = 0.2, alpha = 0.3) + 
                        theme_classic() +
                        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                        geom_text(data = letters_df, aes(x = Textural.class, y = max(merged_sample_data_iso$Shannon)  * 1.1, 
                                                         label = Letters), 
                                  vjust = -0.5, color = "darkgray", size = 4) +
                        scale_fill_manual(values = colorvec, name = NULL) +
                        scale_x_discrete(labels = labelsvec) +
                        theme(legend.position = "none")+
                        annotate("text", x = 2.5, y = max(merged_sample_data_iso$Shannon) + 1.27, label = p_value_text, size = 4) +
                        coord_cartesian(ylim = c(0, max(merged_sample_data_iso$Shannon) + 1.35))


sha_Textural.class_plot
```

## Sobs

Now we will do the same with Sobs

###Location:

```{r}
#Location

# Perform the Kruskal-Wallis test
kruskal_test <- kruskal.test(Sobs ~ Soil.Id, data = merged_sample_data_iso)

# Print the result of the Kruskal-Wallis test
print(kruskal_test)

# Extract the p-value
p_value <- kruskal_test$p.value

# Format the p-value for display
p_value_text <- paste0("p = ", formatC(p_value, format = "e", digits = 2))

# Perform pairwise comparisons using Wilcox on rank-sum test
pairwise_comparisons <- pairwise.wilcox.test(merged_sample_data_iso$Sobs, merged_sample_data_iso$Soil.Id, p.adjust.method = "BH")

# Print the pairwise comparison results
print(pairwise_comparisons)

p_values_matrix <- pairwise_comparisons$p.value

# Generate letters for significant differences using the custom function
significant_letters <- generate_significant_letters(p_values_matrix)


# Create a data frame for the letters to use in plotting
letters_df <- data.frame(Soil.Id = names(significant_letters), Letters = significant_letters)

# Create a boxplot with letters
sobs_loc_plot <- ggplot(merged_sample_data_iso, aes(x = Soil.Id, y = Sobs, fill = Soil.Id)) +
                        geom_boxplot() +
                        labs(x = "Location", y = "Sobs") +
                        geom_jitter(show.legend = FALSE, width = 0.2, alpha = 0.3) + 
                        theme_classic() +
                        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                        geom_text(data = letters_df, aes(x = Soil.Id, y = max(merged_sample_data_iso$Sobs) * 1.1, 
                                                         label = Letters), 
                                  vjust = -0.5, color = "darkgray", size = 4) +
                        scale_fill_manual(values = colorvec, name = NULL) +
                        scale_x_discrete(labels = labelsvec) +
                        theme(legend.position = "none")+
                        annotate("text", x = 5, y = max(merged_sample_data_iso$Sobs) * 1.27, label = p_value_text, size = 4) +
                        coord_cartesian(ylim = c(0, max(merged_sample_data_iso$Sobs) * 1.35))


sobs_loc_plot

```

### Crop:

```{r}
#Crop 

library(multcomp)
library(multcompView)

# Perform the Kruskal-Wallis test
kruskal_test <- kruskal.test(Sobs ~ Crop, data = merged_sample_data_iso)

# Print the result of the Kruskal-Wallis test
print(kruskal_test)

# Extract the p-value
p_value <- kruskal_test$p.value

# Format the p-value for display
p_value_text <- paste0("p = ", formatC(p_value, format = "e", digits = 2))

# Perform pairwise comparisons using Wilcox on rank-sum test
pairwise_comparisons <- pairwise.wilcox.test(merged_sample_data_iso$Sobs, merged_sample_data_iso$Crop, p.adjust.method = "BH")

# Print the pairwise comparison results
print(pairwise_comparisons)

p_values_matrix <- pairwise_comparisons$p.value

# Generate letters for significant differences using the custom function
significant_letters <- generate_significant_letters(p_values_matrix)


# Create a data frame for the letters to use in plotting
letters_df <- data.frame(Crop = names(significant_letters), Letters = significant_letters)

# Create a boxplot with letters
sobs_crop_plot <- ggplot(merged_sample_data_iso, aes(x = Crop, y = Sobs, fill = Crop)) +
                        geom_boxplot() +
                        labs(x = "Crop", y = "Sobs") +
                        geom_jitter(show.legend = FALSE, width = 0.2, alpha = 0.3) + 
                        theme_classic() +
                        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                        geom_text(data = letters_df, aes(x = Crop, y = max(merged_sample_data_iso$Sobs)  * 1.1, 
                                                         label = Letters), 
                                  vjust = -0.5, color = "darkgray", size = 4) +
                        scale_fill_manual(values = colorvec, name = NULL) +
                        scale_x_discrete(labels = labelsvec) +
                        theme(legend.position = "none")+
                        annotate("text", x = 4, y = max(merged_sample_data_iso$Sobs) * 1.27, label = p_value_text, size = 4) +
                        coord_cartesian(ylim = c(0, max(merged_sample_data_iso$Sobs) * 1.35))

sobs_crop_plot



```


### Soil type:

```{r}
library(multcomp)
library(multcompView)

# Soil type

# Perform the Kruskal-Wallis test
kruskal_test <- kruskal.test(Sobs ~ Textural.class, data = merged_sample_data_iso)

# Print the result of the Kruskal-Wallis test
print(kruskal_test)

# Extract the p-value
p_value <- kruskal_test$p.value

# Format the p-value for display
p_value_text <- paste0("p = ", formatC(p_value, format = "e", digits = 2))

# Perform pairwise comparisons using Wilcox on rank-sum test
pairwise_comparisons <- pairwise.wilcox.test(merged_sample_data_iso$Sobs, merged_sample_data_iso$Textural.class, p.adjust.method = "BH")

# Print the pairwise comparison results
print(pairwise_comparisons)

p_values_matrix <- pairwise_comparisons$p.value

# Generate letters for significant differences using the custom function
significant_letters <- generate_significant_letters(p_values_matrix)


# Create a data frame for the letters to use in plotting
letters_df <- data.frame(Textural.class = names(significant_letters), Letters = significant_letters)

# Create a boxplot with letters
sobs_Textural.class_plot <- ggplot(merged_sample_data_iso, aes(x = Textural.class, y = Sobs, fill = Textural.class)) +
                        geom_boxplot() +
                        labs(x = "Soil type", y = "Sobs") +
                        geom_jitter(show.legend = FALSE, width = 0.2, alpha = 0.3) + 
                        theme_classic() +
                        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                        geom_text(data = letters_df, aes(x = Textural.class, y = max(merged_sample_data_iso$Sobs)  * 1.1, 
                                                         label = Letters), 
                                  vjust = -0.5, color = "darkgray", size = 4) +
                        scale_fill_manual(values = colorvec, name = NULL) +
                        scale_x_discrete(labels = labelsvec) +
                        theme(legend.position = "none")+
                        annotate("text", x = 2.5, y = max(merged_sample_data_iso$Sobs) * 1.27, label = p_value_text, size = 4) +
                        coord_cartesian(ylim = c(0, max(merged_sample_data_iso$Sobs) * 1.35))

# Print the plot
sobs_Textural.class_plot
```

## Pielou

Now we will do the same with Pielou

### Location:

```{r}

#Location

# Perform the Kruskal-Wallis test
kruskal_test <- kruskal.test(Pielou ~ Soil.Id, data = merged_sample_data_iso)

# Print the result of the Kruskal-Wallis test
print(kruskal_test)

# Extract the p-value
p_value <- kruskal_test$p.value

# Format the p-value for display
p_value_text <- paste0("p = ", formatC(p_value, format = "e", digits = 2))

# Perform pairwise comparisons using Wilcox on rank-sum test
pairwise_comparisons <- pairwise.wilcox.test(merged_sample_data_iso$Pielou, merged_sample_data_iso$Soil.Id, p.adjust.method = "BH")

# Print the pairwise comparison results
print(pairwise_comparisons)

p_values_matrix <- pairwise_comparisons$p.value

# Generate letters for significant differences using the custom function
significant_letters <- generate_significant_letters(p_values_matrix)


# Create a data frame for the letters to use in plotting
letters_df <- data.frame(Soil.Id = names(significant_letters), Letters = significant_letters)

# Create a boxplot with letters
Pielou_loc_plot <- ggplot(merged_sample_data_iso, aes(x = Soil.Id, y = Pielou, fill = Soil.Id)) +
                        geom_boxplot() +
                        labs(x = "Location", y = "Pielou") +
                        geom_jitter(show.legend = FALSE, width = 0.2, alpha = 0.3) + 
                        theme_classic() +
                        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                        geom_text(data = letters_df, aes(x = Soil.Id, y = max(merged_sample_data_iso$Pielou, na.rm = TRUE) + 0.1, 
                                                         label = Letters), 
                                  vjust = -0.5, color = "darkgray", size = 4) +
                        scale_fill_manual(values = colorvec, name = NULL) +
                        scale_x_discrete(labels = labelsvec, limits = local_order) +
                        theme(legend.position = "none")+
                        annotate("text", x = 5, y = max(merged_sample_data_iso$Pielou, na.rm = TRUE) + 0.25, label = p_value_text, size = 4) +
                        coord_cartesian(ylim = c(0, max(merged_sample_data_iso$Pielou, na.rm = TRUE) + 0.3 ))


Pielou_loc_plot

```

### Crop:

```{r}
#Location

# Perform the Kruskal-Wallis test
kruskal_test <- kruskal.test(Pielou ~ Crop, data = merged_sample_data_iso)

# Print the result of the Kruskal-Wallis test
print(kruskal_test)

# Extract the p-value
p_value <- kruskal_test$p.value

# Format the p-value for display
p_value_text <- paste0("p = ", formatC(p_value, format = "e", digits = 2))

# Perform pairwise comparisons using Wilcox on rank-sum test
pairwise_comparisons <- pairwise.wilcox.test(merged_sample_data_iso$Pielou, merged_sample_data_iso$Crop, p.adjust.method = "BH")

# Print the pairwise comparison results
print(pairwise_comparisons)

p_values_matrix <- pairwise_comparisons$p.value

# Generate letters for significant differences using the custom function
significant_letters <- generate_significant_letters(p_values_matrix)


# Create a data frame for the letters to use in plotting
letters_df <- data.frame(Crop = names(significant_letters), Letters = significant_letters)

# Create a boxplot with letters
Pielou_crop_plot <- ggplot(merged_sample_data_iso, aes(x = Crop, y = Pielou, fill = Crop)) +
                        geom_boxplot() +
                        labs(x = "Crop", y = "Pielou") +
                        geom_jitter(show.legend = FALSE, width = 0.2, alpha = 0.3) + 
                        theme_classic() +
                        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                        geom_text(data = letters_df, aes(x = Crop, y = max(merged_sample_data_iso$Pielou, na.rm = TRUE)  + 0.1, 
                                                         label = Letters), 
                                  vjust = -0.5, color = "darkgray", size = 4) +
                        scale_fill_manual(values = colorvec, name = NULL) +
                        scale_x_discrete(labels = labelsvec, limits = crop_order) +
                        theme(legend.position = "none")+
                        annotate("text", x = 4, y = max(merged_sample_data_iso$Pielou, na.rm = TRUE) + 0.25, label = p_value_text, size = 4) +
                        coord_cartesian(ylim = c(0, max(merged_sample_data_iso$Pielou, na.rm = TRUE) + 0.3 ))
  
  


Pielou_crop_plot
```


### Soil type:

```{r}
#Soil type

# Perform the Kruskal-Wallis test
kruskal_test <- kruskal.test(Pielou ~ Textural.class, data = merged_sample_data_iso)

# Print the result of the Kruskal-Wallis test
print(kruskal_test)

# Extract the p-value
p_value <- kruskal_test$p.value

# Format the p-value for display
p_value_text <- paste0("p = ", formatC(p_value, format = "e", digits = 2))

# Perform pairwise comparisons using Wilcox on rank-sum test
pairwise_comparisons <- pairwise.wilcox.test(merged_sample_data_iso$Pielou, merged_sample_data_iso$Textural.class, p.adjust.method = "BH")

# Print the pairwise comparison results
print(pairwise_comparisons)

p_values_matrix <- pairwise_comparisons$p.value

# Generate letters for significant differences using the custom function
significant_letters <- generate_significant_letters(p_values_matrix)


# Create a data frame for the letters to use in plotting
letters_df <- data.frame(Textural.class = names(significant_letters), Letters = significant_letters)

# Create a boxplot with letters
Pielou_Textural.class_plot <- ggplot(merged_sample_data_iso, aes(x = Textural.class, y = Pielou, fill = Textural.class)) +
                        geom_boxplot() +
                        labs(x = "Soil type", y = "Pielou") +
                        geom_jitter(show.legend = FALSE, width = 0.2, alpha = 0.3) + 
                        theme_classic() +
                        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                        geom_text(data = letters_df, aes(x = Textural.class, y = max(merged_sample_data_iso$Pielou, na.rm = TRUE)  + 0.1, 
                                                         label = Letters), 
                                  vjust = -0.5, color = "darkgray", size = 4) +
                        scale_fill_manual(values = colorvec, name = NULL) +
                        scale_x_discrete(labels = labelsvec) +
                        theme(legend.position = "none")+
                        annotate("text", x = 2.5, y = max(merged_sample_data_iso$Pielou, na.rm = TRUE) + 0.25, label = p_value_text, size = 4) +
                        coord_cartesian(ylim = c(0, max(merged_sample_data_iso$Pielou, na.rm = TRUE) + 0.3 ))


Pielou_Textural.class_plot
```

## Join plots

```{r, fig.height = 11, fig.width = 9, fig.align = "center"}

library(patchwork)
combined_plot <- (sha_crop_plot  + sha_loc_plot + sha_Textural.class_plot) / (sobs_crop_plot + sobs_loc_plot +   sobs_Textural.class_plot) / (Pielou_crop_plot + Pielou_loc_plot +   Pielou_Textural.class_plot)

alpha_shannon_isolates <- (sha_crop_plot + sha_loc_plot +  sha_Textural.class_plot)

# Add labels to the combined plot
combined_plot <- combined_plot + plot_annotation(tag_levels = 'A')
combined_plot
```

# Taxonomic evaluation of the samples

Let's make plots using with the taxonomic assignment of the ASVs. The goal of the plots is to show the differences due to location, soil type, and crop. 

```{r}
classGlommed = tax_glom(physeq.norm.raref, "Class")
phylGlommed = tax_glom(physeq.norm.raref, "Phylum")

plot_bar(phylGlommed, fill ="Phylum") + 
  cowplot::theme_cowplot()+
  #scale_fill_manual(values = tax_color)+ 
  ylab('Normalized and Rarefied Abundance')+
  theme(axis.text.x=element_text(angle = 90, hjust = 1, vjust = 0.5))

top20class.phy  <- prune_taxa(names(sort(taxa_sums(classGlommed), decreasing = TRUE))[1:20], classGlommed)
library(RColorBrewer)

plot_bar(top20class.phy, fill ="Class") + 
  cowplot::theme_cowplot()+
  scale_fill_manual(values = tax_color) +
  ylab('Relative Abundance')+
  theme(axis.text.x=element_text(angle = 90, hjust = 1, vjust = 0.5))

```

Now we will get the overall abundance of all samples from different locations, crops and soil types.

## Location

```{r}
# Location

classGlommed.locat <- merge_samples(classGlommed, "Soil.Id")

classGlommed.locat <- transform_sample_counts(classGlommed.locat, function(x) x / sum(x)) # convert to relative abundances


top10class.classGlommed.locat  <- prune_taxa(names(sort(taxa_sums(classGlommed.locat), decreasing = TRUE))[1:20], classGlommed.locat)


tax_plot_locat <- plot_bar(top10class.classGlommed.locat, fill ="Class") + 
                            cowplot::theme_cowplot()+
                            scale_fill_manual(values = tax_color)+ 
                            ylab('Relative Abundance')+
                            theme(axis.text.x=element_text(angle = 90, hjust = 1, vjust = 0.5)) +
                            scale_x_discrete(labels = labelsvec, limits = local_order) #, limits = crop_order) +

tax_plot_locat

```

## Crop

```{r}
# Location

classGlommed.crop <- merge_samples(classGlommed, "Crop")

classGlommed.crop <- transform_sample_counts(classGlommed.crop, function(x) x / sum(x)) # convert to relative abundances


top10class.classGlommed.crop  <- prune_taxa(names(sort(taxa_sums(classGlommed.crop), decreasing = TRUE))[1:20], classGlommed.crop)


tax_plot_crop <- plot_bar(top10class.classGlommed.crop, fill ="Class") + 
                            cowplot::theme_cowplot()+
                            scale_fill_manual(values = tax_color)+ 
                            ylab('Relative Abundance')+
                            theme(axis.text.x=element_text(angle = 90, hjust = 1, vjust = 0.5)) +
                            scale_x_discrete(labels = labelsvec, limits = crop_order) 

tax_plot_crop

```


## Textural.class type

```{r}
# Location

classGlommed.soil <- merge_samples(classGlommed, "Textural.class")

classGlommed.soil <- transform_sample_counts(classGlommed.soil, function(x) x / sum(x)) # convert to relative abundances


top10class.classGlommed.soil  <- prune_taxa(names(sort(taxa_sums(classGlommed.soil), decreasing = TRUE))[1:20], classGlommed.soil)


tax_plot_soil <- plot_bar(top10class.classGlommed.soil, fill ="Class") + 
                            cowplot::theme_cowplot()+
                            scale_fill_manual(values = tax_color)+ 
                            ylab('Relative Abundance') + 
                            theme(axis.text.x=element_text(angle = 90, hjust = 1, vjust = 0.5)) +
                            scale_x_discrete(labels = labelsvec) #, limits = crop_order) 

tax_plot_soil
```




Because the top 20 classes are not the same between comparisons and to keep the colors consistent we will create a single color vector associated with plots

```{r}

# Load the necessary library
library(phyloseq)

# Extract the taxonomy table
taxonomy1 <- tax_table(top10class.classGlommed.soil)
taxonomy2 <- tax_table(top10class.classGlommed.locat)
taxonomy3 <- tax_table(top10class.classGlommed.crop)

# Extract unique classes
# Assuming "Class" is the taxonomic rank of interest
classes1 <- unique(taxonomy1[, "Class"])
classes2 <- unique(taxonomy2[, "Class"])
classes3 <- unique(taxonomy3[, "Class"])

# Convert to character vectors
classes1 <- as.character(classes1)
classes2 <- as.character(classes2)
classes3 <- as.character(classes3)

# Combine the class lists and identify non-redundant classes
combined_classes <- unique(c(classes1, classes2, classes3))

# Sort the combined classes alphabetically
combined_classes <- sort(combined_classes)

# Print the non-redundant classes
combined_classes

# Crete a palette with the number of colors needed. Based on [this palette] (https://coolors.co/palette/001219-005f73-0a9396-94d2bd-e9d8a6-ee9b00-ca6702-bb3e03-ae2012-9b2226)

# Now we reprint the plots
tax_plot_soil <- plot_bar(top10class.classGlommed.soil, fill ="Class") + 
                            cowplot::theme_cowplot()+
                            scale_fill_manual(values = tax_color)+ 
                            ylab('Relative Abundance') + 
                            theme(axis.text.x=element_text(angle = 90, hjust = 1, vjust = 0.5)) +
                            scale_x_discrete(labels = labelsvec) #, limits = crop_order) 
tax_plot_crop <- plot_bar(top10class.classGlommed.crop, fill ="Class") + 
                            cowplot::theme_cowplot()+
                            scale_fill_manual(values = tax_color)+ 
                            ylab('Relative Abundance')+
                            theme(axis.text.x=element_text(angle = 90, hjust = 1, vjust = 0.5)) +
                            scale_x_discrete(labels = labelsvec, limits = crop_order) 
tax_plot_locat <- plot_bar(top10class.classGlommed.locat, fill ="Class") + 
                            cowplot::theme_cowplot()+
                            scale_fill_manual(values = tax_color)+ 
                            ylab('Relative Abundance')+
                            theme(axis.text.x=element_text(angle = 90, hjust = 1, vjust = 0.5)) +
                            scale_x_discrete(labels = labelsvec, limits = local_order) #, limits = crop_order) +

```



```{r, fig.height = 4, fig.width = 9, fig.align = "center"}

library(patchwork)
taxa_plot_comb <- (tax_plot_crop  + tax_plot_locat +  tax_plot_soil) + plot_annotation(tag_levels = 'A') + 
  plot_layout(nrow = 1, guides = "collect") &
  theme(legend.position = "bottom", legend.box="vertical", 
        legend.margin=margin(),
        plot.margin = unit(c(2,2,2,2), "mm"),
        text = element_text(size = 10),   # Set global text size (for all text elements)
      legend.text = element_text(size = 8),  # Adjust legend text size
      axis.title = element_text(size = 9),   # Adjust axis title text size
      axis.text = element_text(size = 8))

taxa_plot_comb

taxa_plot_comb_isol <- (tax_plot_crop  + tax_plot_locat +  tax_plot_soil)

```

```{r} 
library(tidyverse)
library(multcompView)


# Taxa aggregation and data formatting
ps_class <- tax_glom(physeq.norm.raref, "Class")
ps_class_rel <- transform_sample_counts(ps_class, function(x) x / sum(x))
df <- psmelt(ps_class_rel)

# Filter to top 20 classes
top_classes <- df %>%
  group_by(Class) %>%
  summarise(mean_abund = mean(Abundance, na.rm = TRUE)) %>%
  slice_max(order_by = mean_abund, n = 20) %>%
  pull(Class)

df_top <- df %>%
  filter(Class %in% top_classes)

# Function to return formatted string: "mean ± sd^group"
format_cell <- function(mean, sd, letter) {
  sprintf("%.3f ± %.3f⁽%s⁾", mean, sd, letter)
}

## Crop

run_anova_tukey_wide <- function(df, class_name, factor_var = "Crop", labelsvec = NULL) {
  df_sub <- df %>% filter(Class == class_name)
  
  # Ensure factor
  df_sub[[factor_var]] <- factor(df_sub[[factor_var]])
  
  model <- aov(as.formula(paste("Abundance ~", factor_var)), data = df_sub)
  tukey <- TukeyHSD(model, factor_var)
  letters <- multcompLetters(tukey[[factor_var]][,"p adj"])$Letters
  
  summary_df <- df_sub %>%
    group_by(.data[[factor_var]]) %>%
    summarise(
      mean = mean(Abundance),
      sd = sd(Abundance),
      .groups = "drop"
    ) %>%
    mutate(
      Class = class_name,
      group = letters[as.character(.data[[factor_var]])],
      Label = if (!is.null(labelsvec)) labelsvec[as.character(.data[[factor_var]])] else as.character(.data[[factor_var]]),
      cell = format_cell(mean, sd, group)
    ) %>% dplyr::select(Class, Label, cell)
  return(summary_df)
}

# Run for all classes and pivot
anova_wide <- map_dfr(top_classes, ~run_anova_tukey_wide(df = df_top, .x, factor_var = "Crop", labelsvec = labelsvec)) %>%
  pivot_wider(names_from = Label, values_from = cell)

# Clean up
anova_wide <- anova_wide %>%
  arrange(Class)

# Display
knitr::kable(
  anova_wide,
  caption = "Mean ± SD (with Tukey group letters) of Class abundance per Crop",
  align = "l"
) 

## Soil 
run_anova_tukey_wide <- function(df, class_name, factor_var = "Soil.Id", labelsvec = NULL) {
  df_sub <- df %>% filter(Class == class_name)
  
  # Ensure factor
  df_sub[[factor_var]] <- factor(df_sub[[factor_var]])
  
  model <- aov(as.formula(paste("Abundance ~", factor_var)), data = df_sub)
  tukey <- TukeyHSD(model, factor_var)
  letters <- multcompLetters(tukey[[factor_var]][,"p adj"])$Letters
  
  summary_df <- df_sub %>%
    group_by(.data[[factor_var]]) %>%
    summarise(
      mean = mean(Abundance),
      sd = sd(Abundance),
      .groups = "drop"
    ) %>%
    mutate(
      Class = class_name,
      group = letters[as.character(.data[[factor_var]])],
      Label = if (!is.null(labelsvec)) labelsvec[as.character(.data[[factor_var]])] else as.character(.data[[factor_var]]),
      cell = format_cell(mean, sd, group)
    ) %>%
    dplyr::select(Class, Label, cell)
  
  return(summary_df)
}

# Run for all classes and pivot
anova_wide <- map_dfr(top_classes, ~run_anova_tukey_wide(df_top, .x, factor_var = "Soil.Id", labelsvec = labelsvec)) %>%
  pivot_wider(names_from = Label, values_from = cell)

# Clean up
anova_wide <- anova_wide %>%
  arrange(Class)

# Display
knitr::kable(
  anova_wide,
  caption = "Mean ± SD (with Tukey group letters) of Class abundance per Soil type",
  align = "l"
)

## Location 
run_anova_tukey_wide <- function(df, class_name, factor_var = "Textural.class", labelsvec = NULL) {
  df_sub <- df %>% filter(Class == class_name)
  
  # Ensure factor
  df_sub[[factor_var]] <- factor(df_sub[[factor_var]])
  
  model <- aov(as.formula(paste("Abundance ~", factor_var)), data = df_sub)
  tukey <- TukeyHSD(model, factor_var)
  letters <- multcompLetters(tukey[[factor_var]][,"p adj"])$Letters
  
  summary_df <- df_sub %>%
    group_by(.data[[factor_var]]) %>%
    summarise(
      mean = mean(Abundance),
      sd = sd(Abundance),
      .groups = "drop"
    ) %>%
    mutate(
      Class = class_name,
      group = letters[as.character(.data[[factor_var]])],
      Label = if (!is.null(labelsvec)) labelsvec[as.character(.data[[factor_var]])] else as.character(.data[[factor_var]]),
      cell = format_cell(mean, sd, group)
    ) %>%
    dplyr::select(Class, Label, cell)
  
  return(summary_df)
}

# Run for all classes and pivot
anova_wide <- map_dfr(top_classes, ~run_anova_tukey_wide(df_top, .x, factor_var = "Textural.class", labelsvec = labelsvec)) %>%
  pivot_wider(names_from = Label, values_from = cell)

# Clean up
anova_wide <- anova_wide %>%
  arrange(Class)

# Display
knitr::kable(
  anova_wide,
  caption = "Mean ± SD (with Tukey group letters) of Class abundance per Location",
  align = "l"
) 

```


# Beta-Diversity analysis



```{r}

NMDS <- ordinate(physeq = physeq.norm.raref, 
                 method = "NMDS", 
                 distance = "bray")

NMDS$stress

iso_bac_phylo_norm <- bac_phylo_norm
save(iso_bac_phylo_norm, file = "../Comparisons/isolate_metabarcode.RData")

NMDS_plot_all <- plot_ordination(physeq = physeq.norm.raref, 
                                   ordination = NMDS, 
                                   color = "Soil.Id", 
                                   shape = "Crop")+
            geom_point(size = 2.5) +
            scale_color_manual(values = colorvec, name = NULL, labels = labelsvec, limits = local_order) +
            scale_shape_manual(values = shapesvec, name = NULL, labels = labelsvec, limits = crop_order) +
            cowplot::theme_cowplot()
            
NMDS_plot_all

```

Now we will repeat the plots highlighting the differences between crops, locations and soil types with colors.

```{r}
library(scales)
# location

NMDS_plot_loc <- plot_ordination(physeq = physeq.norm.raref, 
                                   ordination = NMDS, 
                                   color = "Soil.Id" 
                                   )+
            geom_point(size = 3) +
            scale_color_manual(values = colorvec, name = NULL, labels = labelsvec, limits = local_order) +
            #scale_shape_manual(values = shapesvec, ) +
            cowplot::theme_cowplot()+
             scale_x_continuous(labels = label_number(accuracy = 0.1)) +
             scale_y_continuous(labels = label_number(accuracy = 0.1)) +
            theme(legend.position = "bottom", legend.box="vertical", labels = labelsvec, axis.title = element_blank()) +
            guides(color = guide_legend(ncol=2)) 

            
NMDS_plot_loc

NMDS_plot_crop <- plot_ordination(physeq = physeq.norm.raref, 
                                   ordination = NMDS, 
                                   color = "Crop" 
                                   )+
            geom_point(size = 2.5) +
            scale_color_manual(values = colorvec, name = NULL, labels = labelsvec, limits = crop_order) +
            #scale_shape_manual(values = shapesvec, ) +
            cowplot::theme_cowplot()+
             scale_x_continuous(labels = label_number(accuracy = 0.1)) +
             scale_y_continuous(labels = label_number(accuracy = 0.1)) +
            theme(legend.position = "bottom", legend.box="vertical", labels = labelsvec, axis.title = element_blank()) +
            guides(color = guide_legend(ncol=2)) 

            
NMDS_plot_crop

NMDS_plot_soil <- plot_ordination(physeq = physeq.norm.raref, 
                                   ordination = NMDS, 
                                   color = "Textural.class" 
                                   )+
            geom_point(size = 2.5) +
            scale_color_manual(values = colorvec, name = NULL, labels = labelsvec) +
            #scale_shape_manual(values = shapesvec, ) +
            cowplot::theme_cowplot()+
             scale_x_continuous(labels = label_number(accuracy = 0.1)) +
             scale_y_continuous(labels = label_number(accuracy = 0.1)) +
            theme(legend.position = "bottom", legend.box="vertical", axis.title = element_blank()) +
            guides(color = guide_legend(ncol=2)) 

            
NMDS_plot_soil

```


Now, we will collect the plot in a single figure.


```{r, fig.height = 5, fig.width = 11, fig.align = "center"}
nmds_plot_comb <- (NMDS_plot_loc + NMDS_plot_crop + NMDS_plot_soil) + 
  plot_annotation(tag_levels = 'A') + 
  plot_layout(nrow = 1)
  
nmds_plot_comb

nmds_plot_comb

nmds_plot_comb_isolates <- (NMDS_plot_crop + NMDS_plot_loc + NMDS_plot_soil) & theme(legend.position = "none")

```

# PERMANOVA

We will now perform PERMANOVA tests to see if the differences in the community composition are due to the soil type, location or crop.

```{r}

# Transform the data
ps_tr <- microbiome::transform(physeq.norm.raref, "clr")

ps_dist_matrix <- phyloseq::distance(physeq.norm.raref, method ="bray")

permanova_soil <- vegan::adonis2(ps_dist_matrix ~ phyloseq::sample_data(ps_tr)$Textural.class)
permanova_crop <- vegan::adonis2(ps_dist_matrix ~ phyloseq::sample_data(ps_tr)$Crop)
permanova_local <- vegan::adonis2(ps_dist_matrix ~ phyloseq::sample_data(ps_tr)$Soil.Id)

knitr::kable(as.data.frame(permanova_soil), digits = 4, caption = "PERMANOVA soil results")
knitr::kable(as.data.frame(permanova_crop), digits = 4, caption = "PERMANOVA crop results")
knitr::kable(as.data.frame(permanova_local), digits = 4, caption = "PERMANOVA location results")

```

# Pairwise PERMANOVA

We will now perform pairwise PERMANOVA tests to see if the differences in the community composition are due to the soil type, location or crop.

```{r}
library(pairwiseAdonis)

pairwise.adonis(ps_dist_matrix, phyloseq::sample_data(ps_tr)$Textural.class)
pairwise.adonis(ps_dist_matrix, phyloseq::sample_data(ps_tr)$Crop)
pairwise.adonis(ps_dist_matrix, phyloseq::sample_data(ps_tr)$Soil.Id)

```

# PERMDIST

We will now perform PERMDIST tests to see if the differences in the community composition are due to the soil type, location or crop.

```{r}

# Perform PERMDIST
#soil 
soil_type_permdist <- vegan::betadisper(ps_dist_matrix, phyloseq::sample_data(ps_tr)$Textural.class, type = "centroid")
anova(soil_type_permdist)

#location
loc_type_permdist <- vegan::betadisper(ps_dist_matrix, phyloseq::sample_data(ps_tr)$Soil.Id, type = "centroid")
anova(loc_type_permdist)

#crop
crop_type_permdist <- vegan::betadisper(ps_dist_matrix, phyloseq::sample_data(ps_tr)$Crop, type = "centroid")
anova(crop_type_permdist)



```
Because the PERMDIST test indicated that the dispersal of the samples is significant as were the PERMANOVA tests we cannot affirm that the are due to Soil type, location or crop because PERMANOVA assumes that distances are homogeneous. 

# ANOSIM

Because the PERMANOVA results are not reliable we will use the non-parametric ANOSIM test. 

```{r}
# Soil type
vegan::anosim(ps_dist_matrix, phyloseq::sample_data(ps_tr)$Textural.class, distance = "bray", permutations = 999)

# Location
vegan::anosim(ps_dist_matrix, phyloseq::sample_data(ps_tr)$Soil.Id, distance = "bray", permutations = 999)
# Crop
vegan::anosim(ps_dist_matrix, phyloseq::sample_data(ps_tr)$Crop, distance = "bray", permutations = 999)

```




#####################################################
# Taxonomic evaluation of the samples

Let's make plots using with the taxonomic assignment of the ASVs. The goal of the plots is to show the differences due to location, soil type, and crop. 

```{r taxonomy}


library(ggplot2)

classGlommed = tax_glom(bac_phylo_norm, "Order")
phylGlommed = tax_glom(bac_phylo_norm, "Phylum")

plot_bar(phylGlommed, fill ="Phylum") + 
  cowplot::theme_cowplot()+
  #scale_fill_manual(values = tax_color)+ 
  ylab('Normalized and Rarefied Abundance')+
  theme(axis.text.x=element_text(angle = 90, hjust = 1, vjust = 0.5))

top20class.phy  <- prune_taxa(names(sort(taxa_sums(classGlommed), decreasing = TRUE))[1:20], classGlommed)
library(RColorBrewer)
tax_color <- colorRampPalette(c("#da2c38", "#226f54", "#87c38f", "#f4f0bb", "#43291f"))(21)

plot_bar(top20class.phy, fill ="Order") + 
  cowplot::theme_cowplot()+
  scale_fill_manual(values = tax_color)+ 
  ylab('Relative Abundance')+
  theme(axis.text.x=element_text(angle = 90, hjust = 1, vjust = 0.5))

```

Now we will get the overall abundance of all samples from different locations, crops and soil types.

## Location

```{r}
# Location

classGlommed.locat <- merge_samples(classGlommed, "Soil.Id")

classGlommed.locat <- transform_sample_counts(classGlommed.locat, function(x) x / sum(x)) # convert to relative abundances


top10class.classGlommed.locat  <- prune_taxa(names(sort(taxa_sums(classGlommed.locat), decreasing = TRUE))[1:20], classGlommed.locat)


tax_plot_locat <- plot_bar(top10class.classGlommed.locat, fill ="Order") + 
                            cowplot::theme_cowplot()+
                            scale_fill_manual(values = tax_color)+ 
                            ylab('Relative Abundance')+
                            theme(axis.text.x=element_text(angle = 90, hjust = 1, vjust = 0.5)) +
                            scale_x_discrete(labels = labelsvec, limits = local_order) #, limits = crop_order) +

tax_plot_locat

```

## Crop

```{r}
# Location

classGlommed.crop <- merge_samples(classGlommed, "Crop")

classGlommed.crop <- transform_sample_counts(classGlommed.crop, function(x) x / sum(x)) # convert to relative abundances


top10class.classGlommed.crop  <- prune_taxa(names(sort(taxa_sums(classGlommed.crop), decreasing = TRUE))[1:20], classGlommed.crop)


tax_plot_crop <- plot_bar(top10class.classGlommed.crop, fill ="Order") + 
                            cowplot::theme_cowplot()+
                            scale_fill_manual(values = tax_color)+ 
                            ylab('Relative Abundance')+
                            theme(axis.text.x=element_text(angle = 90, hjust = 1, vjust = 0.5)) +
                            scale_x_discrete(labels = labelsvec, limits = crop_order) 

tax_plot_crop

```



## Soil type

```{r}
# Location

classGlommed.soil <- merge_samples(classGlommed, "Textural.class")

classGlommed.soil <- transform_sample_counts(classGlommed.soil, function(x) x / sum(x)) # convert to relative abundances


top10class.classGlommed.soil  <- prune_taxa(names(sort(taxa_sums(classGlommed.soil), decreasing = TRUE))[1:20], classGlommed.soil)


tax_plot_soil <- plot_bar(top10class.classGlommed.soil, fill ="Order") + 
                            cowplot::theme_cowplot()+
                            scale_fill_manual(values = tax_color)+ 
                            ylab('Relative Abundance') + 
                            theme(axis.text.x=element_text(angle = 90, hjust = 1, vjust = 0.5)) +
                            scale_x_discrete(labels = labelsvec) #, limits = crop_order) 

tax_plot_soil
```

Because the top 20 classes are not the same between comparisons and to keep the colors consistent we will create a single color vector associated with plots

```{r}

# Load the necessary library
library(phyloseq)

# Extract the taxonomy table
taxonomy1 <- tax_table(top10class.classGlommed.soil)
taxonomy2 <- tax_table(top10class.classGlommed.locat)
taxonomy3 <- tax_table(top10class.classGlommed.crop)

# Extract unique classes
# Assuming "Order" is the taxonomic rank of interest
classes1 <- unique(taxonomy1[, "Order"])
classes2 <- unique(taxonomy2[, "Order"])
classes3 <- unique(taxonomy3[, "Order"])

# Convert to character vectors
classes1 <- as.character(classes1)
classes2 <- as.character(classes2)
classes3 <- as.character(classes3)

# Combine the class lists and identify non-redundant classes
combined_classes <- unique(c(classes1, classes2, classes3))

# Sort the combined classes alphabetically
combined_classes <- sort(combined_classes)

# Print the non-redundant classes
combined_classes

# Crete a palette with the number of colors needed. Based on [this palette] (https://coolors.co/palette/001219-005f73-0a9396-94d2bd-e9d8a6-ee9b00-ca6702-bb3e03-ae2012-9b2226)

library(RColorBrewer)
colors_new <- colorRampPalette(c("#da2c38", "#226f54", "#87c38f", "#f4f0bb", "#43291f"))(length(combined_classes))

# Create the named vector
tax_color <- setNames(colors_new, combined_classes)

# Print the resulting named vector
print(tax_color)

# Now we reprint the plots
tax_plot_soil <- plot_bar(top10class.classGlommed.soil, fill ="Order") + 
                            cowplot::theme_cowplot()+
                            scale_fill_manual(values = tax_color)+ 
                            ylab('Relative Abundance') + 
                            theme(axis.text.x=element_text(angle = 90, hjust = 1, vjust = 0.5)) +
                            scale_x_discrete(labels = labelsvec) #, limits = crop_order) 
tax_plot_crop <- plot_bar(top10class.classGlommed.crop, fill ="Order") + 
                            cowplot::theme_cowplot()+
                            scale_fill_manual(values = tax_color)+ 
                            ylab('Relative Abundance')+
                            theme(axis.text.x=element_text(angle = 90, hjust = 1, vjust = 0.5)) +
                            scale_x_discrete(labels = labelsvec, limits = crop_order) 
tax_plot_locat <- plot_bar(top10class.classGlommed.locat, fill ="Order") + 
                            cowplot::theme_cowplot()+
                            scale_fill_manual(values = tax_color)+ 
                            ylab('Relative Abundance')+
                            theme(axis.text.x=element_text(angle = 90, hjust = 1, vjust = 0.5)) +
                            scale_x_discrete(labels = labelsvec, limits = local_order) #, limits = crop_order) +

```



```{r, fig.height = 7, fig.width = 9, fig.align = "center"}

library(patchwork)
taxa_plot_comb <- (tax_plot_crop + tax_plot_locat + tax_plot_soil) + plot_annotation(tag_levels = 'A') + 
  plot_layout(nrow = 1, guides = "collect") &
  theme(legend.position = "bottom", legend.box="vertical", 
        legend.margin=margin(),
        plot.margin = unit(c(2,2,2,2), "mm"),
        text = element_text(size = 10),   # Set global text size (for all text elements)
      legend.text = element_text(size = 8),  # Adjust legend text size
      axis.title = element_text(size = 9),   # Adjust axis title text size
      axis.text = element_text(size = 8))

taxa_plot_comb

```
```{r}

save(alpha_shannon_isolates, nmds_plot_comb_isolates, taxa_plot_comb_isol, merged_sample_data_iso, file = "../Comparisons/isolate_metabarcode_figs.RData")

```

```{r}
installed.packages()[names(sessionInfo()$otherPkgs), "Version"]
``` 